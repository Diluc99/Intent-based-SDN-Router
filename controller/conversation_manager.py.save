#!/usr/bin/env python3
import os
import time
import logging
from logging.handlers import RotatingFileHandler
from dotenv import load_dotenv
from groq import Groq
from intent_parser_v2 import IntentParser

# Configure logging
log_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'logs')
os.makedirs(log_dir, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        RotatingFileHandler(
            os.path.join(log_dir, 'controller.log'),
            maxBytes=1024*1024,  # 1MB
            backupCount=5
        ),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ConversationManager:
    def __init__(self):
        load_dotenv()
        self.use_llm = os.getenv('USE_LLM', 'false').lower() == 'true'
        self.max_history = int(os.getenv('MAX_CHAT_HISTORY', 10))
        self.timeout = int(os.getenv('CONVERSATION_TIMEOUT', 300))
        self.intent_parser = IntentParser()
        self.conversations = {}  # In-memory conversation storage
        self.groq_client = None

        if not self.use_llm:
            logger.error("LLM mode is required (USE_LLM=true in .env). Exiting.")
            raise ValueError("LLM mode is required. Set USE_LLM=true in .env.")
        
        try:
            api_key = os.getenv('GROQ_API_KEY')
            if not api_key:
                logger.error("GROQ_API_KEY not set in .env. Exiting.")
                raise ValueError("GROQ_API_KEY not set in .env")
            self.groq_client = Groq(api_key=api_key)  # No proxies parameter
            logger.info("âœ… Groq LLM initialized")
        except Exception as e:
            logger.error(f"Failed to initialize Groq: {e}. Exiting.")
            raise

        logger.info("Conversation Manager initialized")

    def process_message(self, user_id, message):
        """Process user message using Groq LLM"""
        if user_id not in self.conversations:
            self.conversations[user_id] = {'history': [], 'last_active': time.time()}

        # Clean up old conversations
        self._cleanup_conversations()

        # Process with LLM
        response = self._process_with_llm(message)

        self.conversations[user_id]['history'].append({'user': message, 'bot': response})
        if len(self.conversations[user_id]['history']) > self.max_history:
            self.conversations[user_id]['history'].pop(0)
        self.conversations[user_id]['last_active'] = time.time()

        return response

    def _process_with_llm(self, message):
        """Process message using Groq LLM"""
        try:
            system_prompt = """
            You are a conversational AI for an SDN router. Translate user requests into network intents (e.g., QoS, traffic shaping).
            Ask ONE clarification question if the request is ambiguous. Return JSON with 'response' and optional 'intent' or 'needs_clarification'.
            """
           completion = self.groq_client.chat.completions.create(
    model=os.getenv('GROQ_MODEL', 'llama-3.3-70b-versatile'),  # Updated default
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": message}
    ],
    response_format={"type": "json_object"}
)
            return completion.choices[0].message.content
        except Exception as e:
            logger.error(f"LLM processing failed: {e}")
            return {"response": "Sorry, there was an error processing your request with the LLM."}

    def _cleanup_conversations(self):
        """Remove expired conversations"""
        current_time = time.time()
        expired = [uid for uid, conv in self.conversations.items()
                  if current_time - conv['last_active'] > self.timeout]
        for uid in expired:
            del self.conversations[uid]
            logger.info(f"Cleaned up conversation for user {uid}")

    def get_conversation_history(self, user_id):
        """Return conversation history for a user"""
        return self.conversations.get(user_id, {}).get('history', [])
